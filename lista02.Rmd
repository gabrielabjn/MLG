---
title: "Lista 02 - MLG"
author: "Gabriela Paschoal"
date: "2025-03-06"
output: pdf_document
---

## Livro Gilberto Paula, cap. 02 (2013)

#### Sumário
- [Exercício 07](#ex07)
- [Exercício 15](#ex15)
- [Exercício 16](#ex16)

#### Exercício 07 {#ex07}

```{r setup, include=FALSE, echo=FALSE, message=FALSE, warning=FALSE}

library(dplyr)
library(ggplot2)
library(tidyr)
library(nortest)
library(AICcmodavg)

# assimetria no caso da dist gama eh soh da variavel resposta?

```

Pela análise dos gráficos, podemos perceber que, considerando a temperatura de 170ºC, a resistência mediana do vidro foi maior com as voltagens 200 e 250 kV (1000 horas e 800 horas, respectivamente), no entanto, apresentou alta variabilidade. Já com as voltagens de 300 e 350 kV, o vidro apresentou menor resistência mediana (entre 300 e 400 horas), porém essa resistência se mostrou mais consistente (menor variabilidade).

Agora, considerando a temperatura de 180º, as medianas da resistência para as voltagens 250, 300 e 350 ficaram relativamente próximas (entre 350 e 400 horas), com pequenas variabilidades (a menor foi registrada para 300 kV). Já a voltagem 200 kV está relacionada à maior resistência mediana (acima de 1000 kV), com essa resistência também se mostrando consistente.

```{r, echo=FALSE, message=FALSE, warning=FALSE, fig.width=4, fig.height=3, fig.align='center'}

df <- data.frame(
  Temperature = c(rep(170, 4), rep(180, 4)),
  Voltage_200 = c(439, 904, 1092, 1105, 959, 1065, 1065, 1087),
  Voltage_250 = c(572, 690, 904, 1090, 216, 315, 455, 473),
  Voltage_300 = c(315, 315, 439, 628, 241, 315, 332, 380),
  Voltage_350 = c(258, 258, 347, 588, 241, 241, 435, 455)
)

# 170 --------------------------------------------------------------------------

df_170 <- df %>% filter(Temperature == 170)

df_170_long <- df_170 %>%
  pivot_longer(cols = starts_with("Voltage"), names_to = "Voltage", values_to = "Value")

ggplot(df_170_long, aes(x = Voltage, y = Value)) +
  geom_boxplot() +
  labs(title = "Voltagens para 170°C",
       x = "Voltagem (kV)",
       y = "Valores") +
  theme_minimal()


estatisticas_170 <-df_170 %>%
  summarise(across(starts_with("Voltage"), 
            list(mean = ~ mean(.), 
                 sd = ~ sd(.), 
                 cv = ~ sd(.) / mean(.) * 100)))

data.frame(
  Estatística = c("Média", "DP", "CV (%)"),
  V200 = round(c(estatisticas_170$Voltage_200_mean, estatisticas_170$Voltage_200_sd, estatisticas_170$Voltage_200_cv),2),
  V250 = round(c(estatisticas_170$Voltage_250_mean, estatisticas_170$Voltage_250_sd, estatisticas_170$Voltage_250_cv),2),
  V300 = round(c(estatisticas_170$Voltage_300_mean, estatisticas_170$Voltage_300_sd, estatisticas_170$Voltage_300_cv),2),
  V350 = round(c(estatisticas_170$Voltage_350_mean, estatisticas_170$Voltage_350_sd, estatisticas_170$Voltage_350_cv),2)
)

# 180 --------------------------------------------------------------------------

df_180 <- df %>% filter(Temperature == 180)

df_180_long <- df_180 %>%
  pivot_longer(cols = starts_with("Voltage"), names_to = "Voltage", values_to = "Value")

ggplot(df_180_long, aes(x = Voltage, y = Value)) +
  geom_boxplot() +
  labs(title = "Voltagens para 180°C",
       x = "Voltagem (kV)",
       y = "Valores") +
  theme_minimal()

estatisticas_180 <-df_180 %>%
  summarise(across(starts_with("Voltage"), 
            list(mean = ~ mean(.), 
                 sd = ~ sd(.), 
                 cv = ~ sd(.) / mean(.) * 100)))

data.frame(
  Estatística = c("Média", "DP", "CV (%)"),
  V200 = round(c(estatisticas_180$Voltage_200_mean, estatisticas_180$Voltage_200_sd, estatisticas_180$Voltage_200_cv),2),
  V250 = round(c(estatisticas_180$Voltage_250_mean, estatisticas_180$Voltage_250_sd, estatisticas_180$Voltage_250_cv),2),
  V300 = round(c(estatisticas_180$Voltage_300_mean, estatisticas_180$Voltage_300_sd, estatisticas_180$Voltage_300_cv),2),
  V350 = round(c(estatisticas_180$Voltage_350_mean, estatisticas_180$Voltage_350_sd, estatisticas_180$Voltage_350_cv),2)
)

```

**O Modelo Gama**

Como a distribuição é **assimétrica**, uma distribuição gama ou inversa gaussiana pode ser adequada. Inicialmente, usamos uma parametrização de casela de referência sem interação, mas queremos verificar se a interação entre temperatura e voltagem é significativa - nesse caso, podemos estender o modelo para incluir termos de interação:

$$\mu_{ij} = \alpha+\beta_j+\gamma+\sigma_{ij}$$

Onde $\sigma_{ij}$ apresenta a interação entre temperatura e voltagem.

Inicialmente, vamos assumir uma distribuição Gama para a variável resposta, já que ela é adequada para dados assimétricos e positivos.

```{r, echo=FALSE, message=FALSE, warning=FALSE, fig.width=4, fig.height=3, fig.align='center'}

# Preparar os dados
df_long <- df %>%
  pivot_longer(cols = starts_with("Voltage"), names_to = "Voltage", values_to = "Resistance") %>%
  mutate(Temperature = as.factor(Temperature),
         Voltage = as.factor(Voltage))

# Ajustar o modelo sem interação (casela de referência)
modelo_sem_interacao <- glm(Resistance ~ Temperature + Voltage, 
                            data = df_long, 
                            family = Gamma(link = "log"))


# Ajustar o modelo com interação
modelo_com_interacao <- glm(Resistance ~ Temperature * Voltage, 
                            data = df_long, 
                            family = Gamma(link = "log"))

# Comparar os modelos
anova(modelo_sem_interacao, modelo_com_interacao, test = "Chisq")


```
O teste de razão de verossimilhança usando ANOVA compara o modelo sem interação com o modelo contendo a interação. Como o p-valor se mostrou significativo a $5\%$, ficamos com o modelo com a interação.

```{r, echo=FALSE, message=FALSE, warning=FALSE, fig.width=4, fig.height=3, fig.align='center'}

summary(modelo_com_interacao)


```
Os coeficientes do modelo indicam como a temperatura e a voltagem afetam a resistência média, sendo o intercepto ($\alpha$) o efeito da casela de referência (170ºC e 200 kV), os coeficientes das voltagens($\beta_{ìj}$), os efeitos dessas em relação à casela de referência; Da mesma forma, o coeficiente da temperatura 180º, ou $\gamma$, é o efeito dessa tenmperatura em relação à casela de referência. Por fim, $\sigma_{ij}$ representa o efeito da interação entre temperatura e voltagem.

Como os coeficientes para as voltagens 300 e 350 kV se mostraram negativos e significativos, concluímos que essas voltagens reduzem a resistência média do vidro (em relação à casela de referência, ou seja, 200 kV na temperatura 170º). Além disso obtivemos que $\sigma_{22}$ também se mostrou significativo, ou seja, há evidências para acreditar que exista interação entre a temperatura de 180ºC e a voltagem de 250 kV, e que essa interação cause uma redução da resistência média do vidro (em relação ao efeito da voltagem na temperatura 170ºC).

Como $\beta_3$ = -0,73, a voltagem de 300 kV reduz a resistência média em 52% ($1-e^{-0.73}\approx0.52$) )em relação a 200 kV (na temperatura de referência, ou seja, 170ºC). Já a voltagem de 350 kV reduz em 59 vezes a resistência média em relação à temperatura de referência. Por fim, a voltagem de 250 reduz a resistência média em 8 vezes quando a temperatura é de 180ºC.

**Análise de Diagnóstico - Gama**

RESÍDUOS

O teste de Shapiro e de Lilliefors não rejeitou a hipótese de normalidade dos resíduos do modelo. Além disso, os resíduos se mostraram relativamente bem ajustados, evidenciado pelos gráficos quartil-quartil e envelope.

```{r, echo=FALSE, message=FALSE, warning=FALSE, fig.width=4, fig.height=3, fig.align='center'}
res<-modelo_com_interacao$residuals
shapiro.test(res)
lillie.test(res)
hist(res, main='Resíduos', freq = FALSE, xlab='resíduos')
fit.model<-modelo_com_interacao
source("MLG/Funcoes/envel_gama_log.txt") 
```

ADEQUAÇÃO DA FUNÇÃO DE LIGAÇÃO

Como a estatística do teste da RV abaixo se mostrou não-significativa, não rejeitamos a hipótese de que o modelo sem o termo ao quadrado está melhor especificado. 

```{r, echo=FALSE, message=FALSE, warning=FALSE, fig.width=4, fig.height=3, fig.align='center'}

source("MLG/Funcoes/rv.gama.txt")
source("MLG/Funcoes/eta2.gama.txt")
eta2.gama(fit.model) 
# H0: o modelo já está corretamente especificado, ou seja,
#nao ha necessidade de add eta^2 como covariavel
```
PONTOS DE ALAVANCA?

Não foram identificados pontos de alavanca.


```{r, echo=FALSE, message=FALSE, warning=FALSE, fig.width=4, fig.height=3, fig.align='center'}

X <- model.matrix(fit.model)

V <- fitted(fit.model)  # vetor de valores ajustados (model$fitted.values)
Vm <- diag(V)

w <- fit.model$weights  # vetor de pesos
W <- diag(w)
H1 <- solve(t(X)%*%W%*%X)
H <- sqrt(W)%*%X%*%H1%*%t(X)%*%sqrt(W)
hii <- diag(H)  # vetor diagonal de H

# Res?duos
rD <- resid(fit.model, type= "deviance")

fi<-gamma.shape(fit.model)$alpha
tD <- rD*sqrt(fi/(1-hii))   # residuo deviance padronizado

#rp1 <- resid(fit.model, type= "pearson")
#rP <- as.numeric(sqrt(fi)*rp1)
#tS <- rP/sqrt(V*(1 - hii)) 
```

```{r, echo=FALSE, message=FALSE, warning=FALSE, fig.width=4, fig.height=3, fig.align='center'}
V <- fitted(fit.model) 
hii <- diag(H)

plot(V,hii)
plot(hii)

```

**O Modelo da Normal Inversa**

Vamos repetir o procedimento feito anteriormente para a distribuição gama, verificando inicialmente a significância da interaçãoentre temperatura e voltagem no modelo.


```{r, echo=FALSE, message=FALSE, warning=FALSE, fig.width=4, fig.height=3, fig.align='center'}

# Ajustar o modelo sem interação (casela de referência)
modelo_sem_interacao2 <- glm(Resistance ~ Temperature + Voltage, 
                            data = df_long, 
                            family = inverse.gaussian(link = "log"))


# Ajustar o modelo com interação
modelo_com_interacao2 <- glm(Resistance ~ Temperature * Voltage, 
                            data = df_long, 
                            family = inverse.gaussian(link = "log"))

# Comparar os modelos
anova(modelo_sem_interacao2, modelo_com_interacao2, test = "Chisq")


```

Como o p-valor não se mostrou significativo a $5\%$, ficamos com a hipótese nula, ou seja, o modelo sem a interação.

```{r, echo=FALSE, message=FALSE, warning=FALSE, fig.width=4, fig.height=3, fig.align='center'}

summary(modelo_sem_interacao2)


```

Interpretação: todas as variáveis explicativas (e o intercepto) se mostraram significativas a 5%. A temperatura de 180ºC é negativa e responsável por uma redução de 24% da resistência do vidro, quando comparada à temperatura de 170º. As voltagens 250, 300 e 350 kV também estão associadas a reduções da resistência do vidro, quando comparadas à voltagem de 200 kV na temperatura de 170ºC.

**Análise de Diagnóstico - Inversa Gaussiana**

RESÍDUOS

O teste de Shapiro e de Lilliefors não rejeitou a hipótese de normalidade dos resíduos do modelo. Além disso, os resíduos se mostraram relativamente bem ajustados, evidenciado pelos gráfico envelope.

```{r, echo=FALSE, message=FALSE, warning=FALSE, fig.width=4, fig.height=3, fig.align='center'}
res<-modelo_sem_interacao2$residuals
shapiro.test(res)
lillie.test(res)
hist(res, main='Resíduos', freq = FALSE, xlab='resíduos')
fit.model<-modelo_sem_interacao2
source("MLG/Funcoes/envel_norm.txt") 
```

ADEQUAÇÃO DA FUNÇÃO DE LIGAÇÃO

Como a estatística do teste da RV abaixo se mostrou não-significativa, não rejeitamos a hipótese de que o modelo sem o termo ao quadrado está melhor especificado. 

```{r, echo=FALSE, message=FALSE, warning=FALSE, fig.width=4, fig.height=3, fig.align='center'}

source("MLG/Funcoes/rv.ig.txt")
source("MLG/Funcoes/eta2.ig.txt", encoding='latin1')
eta2.ig(fit.model) 
# H0: o modelo já está corretamente especificado, ou seja,
#nao ha necessidade de add eta^2 como covariavel
```

PONTOS DE ALAVANCA?

Não foram identificados pontos de alavanca gritantes.

```{r, echo=FALSE, message=FALSE, warning=FALSE, fig.width=4, fig.height=3, fig.align='center'}

X <- model.matrix(fit.model)

V <- fitted(fit.model)  # vetor de valores ajustados (model$fitted.values)
Vm <- diag(V)

w <- fit.model$weights  # vetor de pesos
W <- diag(w)
H1 <- solve(t(X)%*%W%*%X)
H <- sqrt(W)%*%X%*%H1%*%t(X)%*%sqrt(W)
hii <- diag(H)  # vetor diagonal de H

# Res?duos
rD <- resid(fit.model, type= "deviance")
tD <- rD*sqrt(fi/(1-hii))   # residuo deviance padronizado
#fi=gamma.shape(fit.model)$alpha
#rp1 <- resid(fit.model, type= "pearson")
#rP <- as.numeric(sqrt(fi)*rp1)
#tS <- rP/sqrt(V*(1 - hii)) 
```

```{r, echo=FALSE, message=FALSE, warning=FALSE, fig.width=4, fig.height=3, fig.align='center'}
V <- fitted(fit.model) 
hii <- diag(H)

plot(V,hii)
plot(hii)

```

**Melhor Modelo**

Pelo critério do menor AIC, ficamos com o modelo gama (423 contra 429 para a normal inversa). 

```{r, echo=FALSE, message=FALSE, warning=FALSE, fig.width=4, fig.height=3, fig.align='center'}
rm(list=ls())

```

#### Exercício 15 {#ex15}

Dados referentes a 53 domicílios, total de energia consumida (kw/h) e demanda de energia em horário de pico (kw). 

MODELO NORMAL (ERROS HOMOCEDÁSTICOS)

```{r, echo=FALSE, message=FALSE, warning=FALSE, fig.width=4, fig.height=3, fig.align='center'}

txt<-'energy'
url <- paste0('https://www.ime.usp.br/~giapaula/',txt,'.txt')
df <- read.table(url, header = FALSE, dec = ".", stringsAsFactors = FALSE,fill = TRUE)

colnames(df)<-c("Consumo1","Demanda1", "Consumo2","Demanda2","Consumo3","Demanda3",
                "Consumo4","Demanda4")


df<-data.frame(
  Consumo = c(df$Consumo1, df$Consumo2, df$Consumo3, df$Consumo4),
  Demanda = c(df$Demanda1, df$Demanda2, df$Demanda3, df$Demanda4)
  
)




```

```{r, echo=FALSE, message=FALSE, warning=FALSE, fig.width=4, fig.height=3, fig.align='center'}

fit.model<-lm(Demanda~Consumo, data=df)
plot(x=df$Consumo, y=df$Demanda, main="Consumo pela Demanda de Energia")
abline(fit.model)

res<-fit.model$residuals
hist(res)
source("MLG/Funcoes/envel_norm.txt") 

shapiro.test(res)
summary(fit.model)
```
Pela análise dos gráficos, a relação de cada variável explicativa com a respectiva variável resposta parece ser linear. 

MODELO GAMA

A distribuição Gama é frequentemente usada quando a variável resposta é *contínua, positiva e assimétrica*. 

```{r, echo=FALSE, message=FALSE, warning=FALSE, fig.width=4, fig.height=3, fig.align='center'}

hist(df$Demanda,main='Demanda')
hist(df$Consumo,main='Consumo')


```
A especificação do modelo gama ajustado se encontra abaixo. Os resíduos estão relativamente bem ajustados ao envelope.

```{r, echo=FALSE, message=FALSE, warning=FALSE, fig.width=4, fig.height=3, fig.align='center'}

fit<-fit.model # regressao linear comum

fit.model<-glm(Demanda~Consumo, data=df, family=Gamma(link='log'))
summary(fit.model)

source("MLG/Funcoes/envel_gama_log.txt") 

```

ADEQUAÇÃO DA FUNÇÃO DE LIGAÇÃO

O modelo não parece estar bem especificado, já que o p-valor do teste abaixo é significativo a 5%;

```{r, echo=FALSE, message=FALSE, warning=FALSE, fig.width=4, fig.height=3, fig.align='center'}

source("MLG/Funcoes/rv.gama.txt")
source("MLG/Funcoes/eta2.gama.txt")
eta2.gama(fit.model) 
# H0: o modelo já está corretamente especificado, ou seja,
#nao ha necessidade de add eta^2 como covariavel

```
```{r, echo=FALSE, message=FALSE, warning=FALSE, fig.width=4, fig.height=3, fig.align='center'}

fit2_gamalog<-fit.model
fit.model<-glm(Demanda~Consumo, data=df, family=Gamma(link='identity'))
summary(fit.model)

source("MLG/Funcoes/envel_gama_log.txt") 

source("MLG/Funcoes/rv.gama.txt")
source("MLG/Funcoes/eta2.gama.txt")
eta2.gama(fit.model) 
# H0: o modelo já está corretamente especificado, ou seja,
#nao ha necessidade de add eta^2 como covariavel

```
Agora, sim, o modelo parece estar bem especificado (p-valor >> 0.05). 

PONTOS DE ALAVANCA?

Não foram identificados pontos de alavanca.

```{r, echo=FALSE, message=FALSE, warning=FALSE, fig.width=4, fig.height=3, fig.align='center'}

X <- model.matrix(fit.model)

V <- fitted(fit.model)  # vetor de valores ajustados (model$fitted.values)
Vm <- diag(V)

w <- fit.model$weights  # vetor de pesos
W <- diag(w)
H1 <- solve(t(X)%*%W%*%X)
H <- sqrt(W)%*%X%*%H1%*%t(X)%*%sqrt(W)
hii <- diag(H)  # vetor diagonal de H

# Res?duos
rD <- resid(fit.model, type= "deviance")

fi<-gamma.shape(fit.model)$alpha
tD <- rD*sqrt(fi/(1-hii))   # residuo deviance padronizado

#rp1 <- resid(fit.model, type= "pearson")
#rP <- as.numeric(sqrt(fi)*rp1)
#tS <- rP/sqrt(V*(1 - hii)) 
```

PONTOS DE ALAVANCA?

Observação 27 aparenta ser de alavanca. Vamos retirá-la e ajustar novamente o modelo.

```{r, echo=FALSE, message=FALSE, warning=FALSE, fig.width=4, fig.height=3, fig.align='center'}
V <- fitted(fit.model) 
hii <- diag(H)
#plot(V,hii)
plot(hii)



```

```{r, echo=FALSE, message=FALSE, warning=FALSE, fig.width=4, fig.height=3, fig.align='center'}

fit3_gamaIdentity<-fit.model
fit.model<-glm(Demanda~Consumo,data=df[-27,],family=Gamma(link='identity'))
summary(fit.model)
source("MLG/Funcoes/envel_gama_log.txt")

source("MLG/Funcoes/rv.gama.txt")
source("MLG/Funcoes/eta2.gama.txt")
eta2.gama(fit.model) 


```

COMPARAÇÃO DOS MODELOS AJUSTADOS (AIC, AICc, BIC)

O modelo gama com link identidade, sem a observação-alavanca, se mostrou o melhor modelo pelos três critérios considerados. 

```{r, echo=FALSE, message=FALSE, warning=FALSE, fig.width=4, fig.height=3, fig.align='center'}
fit<-lm(Demanda~Consumo, data=df)

cat('AIC: ', '\n')
cat(paste0('Normal: ', round(AIC(fit),2)), '\n') # normal
cat(paste0('Gama Link Log: ', round(AIC(fit2_gamalog),2), '\n')) # gama link log
cat(paste0('Gama link identidade: ', round(AIC(fit3_gamaIdentity),2)), '\n') # gama link identidade
cat(paste0('Gama link identidade sem alavanca: ',round(AIC(fit.model),2)), '\n') # gama link identidade sem alavanca

cat('AICc: ','\n\n')
cat(paste0('Normal: ', round(AICc(fit),2)), '\n') # normal
cat(paste0('Gama Link Log: ', round(AICc(fit2_gamalog),2), '\n')) # gama link log
cat(paste0('Gama link identidade: ', round(AICc(fit3_gamaIdentity),2)), '\n') # gama link identidade
cat(paste0('Gama link identidade sem alavanca: ',round(AICc(fit.model),2)), '\n') # gama link identidade sem alavanca


cat('BIC: ','\n\n')
cat(paste0('Normal: ', round(BIC(fit),2)), '\n') # normal
cat(paste0('Gama Link Log: ', round(BIC(fit2_gamalog),2), '\n')) # gama link log
cat(paste0('Gama link identidade: ', round(BIC(fit3_gamaIdentity),2)), '\n') # gama link identidade
cat(paste0('Gama link identidade sem alavanca: ',round(BIC(fit.model),2)), '\n') # gama link identidade sem alavanca
```
INTERPRETAÇÃO DOS COEFICIENTES

Para cada kilowatts-hora de energia consumida, espera-se que a demanda em horário de pico incremente 0,004 kilowatts. O intercepto é negativo é não apresenta interpretação prática.

```{r, echo=FALSE, message=FALSE, warning=FALSE, fig.width=4, fig.height=3, fig.align='center'}

summary(fit.model)

```

#### Exercício 16 {#ex16}

```{r, echo=FALSE, message=FALSE, warning=FALSE, fig.width=4, fig.height=3, fig.align='center'}

rm(list=ls())

```

MODELO LINEAR NORMAL

```{r, echo=FALSE, message=FALSE, warning=FALSE, fig.width=4, fig.height=3, fig.align='center'}

txt<-'restaurante'
url <- paste0('https://www.ime.usp.br/~giapaula/',txt,'.txt')
df <- read.table(url, header = FALSE, dec = ".", stringsAsFactors = FALSE,fill = TRUE)

colnames(df)<-c("Faturamento","Gasto")

hist(df$Faturamento,main='Faturamento')
hist(df$Gasto, main='Gasto')

fit_normal<-lm(Faturamento~Gasto,data=df)
plot(y=df$Faturamento,x=df$Gasto,main='Faturamento x Gasto (em mil US$)')
abline(fit_normal)

fit.model<-fit_normal
source("MLG/Funcoes/envel_norm.txt") # OK
hist(fit.model$residuals, main='Residuos - Modelo Normal')
shapiro.test(fit.model$residuals) # OK
# Normalidade ok

plot(fit.model$residuals) # homocedasticidade parece ok
abline(h=0)


```

Apenas uma observação (29) apresenta é considerado ponto de avalanca significativo pela distância de Cook. Decidi mantê-la no modelo por não ser um valor tão discrepante dos outros e possível de ocorrer na realidade.


```{r, echo=FALSE, message=FALSE, warning=FALSE, fig.width=4, fig.height=3, fig.align='center'}

leverage <- hatvalues(fit.model) # use para calcular os valores de leverage
# leverage ou hii mede o quanto uma observação influencia o ajuste do modelo.

n <- nrow(df)  # numero de obs
p <- 1        # numero de variaveis independentes
limite <- 2 * (p + 1) / n #Pontos de alavanca são geralmente identificados quando o valor de leverage é maior que 2 * (p + 1) / n.

pontos_alavanca <- which(leverage > limite)


plot(leverage, main = "Pontos de Alavanca", ylab = "Leverage (hii)")
abline(h = limite, col = "red", lty = 2)
points(pontos_alavanca, leverage[pontos_alavanca], col = "red", pch = 19)

# Se você encontrar pontos de alavanca, é importante investigar se eles são influentes (usando métricas como a distância de Cook) e decidir se devem ser tratados ou removidos do modelo.

cook_distance <- cooks.distance(fit.model)
#  Distância de Cook é uma métrica que combina informações sobre leverage (pontos de alavanca) e resíduos para identificar observações que têm uma influência significativa no modelo de regressão. Pontos com uma Distância de Cook alta podem estar distorcendo os resultados do modelo.

limite_cook <- 4 / n
pontos_influentes <- which(cook_distance > limite_cook)

plot(cook_distance, main = "Distância de Cook", ylab = "Distância de Cook")
abline(h = limite_cook, col = "red", lty = 2)
points(pontos_influentes, cook_distance[pontos_influentes], col = "red", pch = 19)


```   
MODELO GAMA

A distribuição da variável resposta (Faturamento) não é assimétrica mas é contínua positiva. A relação entre Faturamento e Gasto é linear, logo irei ajustar uma distribuição gama com ligação identidade.

Os resíduos se mostraram bem ajustados ao envelope. Um ponto de alavanca foi considerado significativamente influente, mas decidi mantê-lo no modelo. Por algum motivo, o teste de hipóteses que verifica a especificação do modelo (inclusão de termo quadrático) não funcionou (p-valor NaN).

```{r, echo=FALSE, message=FALSE, warning=FALSE, fig.width=4, fig.height=3, fig.align='center'}

fit.gama<-glm(Faturamento~Gasto, data=df,family = Gamma(link='identity'))
summary(fit.gama)

fit.model<-fit.gama
source("MLG/Funcoes/envel_gama_ident.txt")

leverage <- hatvalues(fit.model) 
n <- nrow(df) 
p <- 1       
limite <- 2 * (p + 1) / n 

pontos_alavanca <- which(leverage > limite)


plot(leverage, main = "Pontos de Alavanca", ylab = "Leverage (hii)")
abline(h = limite, col = "red", lty = 2)
points(pontos_alavanca, leverage[pontos_alavanca], col = "red", pch = 19)


cook_distance <- cooks.distance(fit.model)

limite_cook <- 4 / n
pontos_influentes <- which(cook_distance > limite_cook)

plot(cook_distance, main = "Distância de Cook", ylab = "Distância de Cook")
abline(h = limite_cook, col = "red", lty = 2)
points(pontos_influentes, cook_distance[pontos_influentes], col = "red", pch = 19)



```

MODELO NORMAL INVERSA

A relação entre Faturamento e Gasto é linear, logo será ajustada uma distribuição gaussiana inversa com ligação identidade. Os resíduos ficaram dentro do envelope. O teste da qualidade de especificação não teve a hipótese nula rejeitada (indicativo de que o modelo está bem especificado e não é necessária a inclusão de termo quadrático).Três pontos de alavanca foram considerados significativamente influentes pela distância de Cook. 


```{r, echo=FALSE, message=FALSE, warning=FALSE, fig.width=4, fig.height=3, fig.align='center'}

fit.IG<-glm(Faturamento~Gasto, data=df,family = inverse.gaussian(link='identity'))
summary(fit.IG)

fit.model<-fit.IG
source("MLG/Funcoes/envel_norm_inverse.txt")


source("MLG/Funcoes/rv.ig.txt")
source("MLG/Funcoes/eta2.ig.txt", encoding='latin1')
eta2.ig(fit.model) 
# H0: o modelo já está corretamente especificado, ou seja,
#nao ha necessidade de add eta^2 como covariavel


leverage <- hatvalues(fit.model) 
n <- nrow(df) 
p <- 1       
limite <- 2 * (p + 1) / n 

pontos_alavanca <- which(leverage > limite)


plot(leverage, main = "Pontos de Alavanca", ylab = "Leverage (hii)")
abline(h = limite, col = "red", lty = 2)
points(pontos_alavanca, leverage[pontos_alavanca], col = "red", pch = 19)


cook_distance <- cooks.distance(fit.model)

limite_cook <- 4 / n
pontos_influentes <- which(cook_distance > limite_cook)

plot(cook_distance, main = "Distância de Cook", ylab = "Distância de Cook")
abline(h = limite_cook, col = "red", lty = 2)
points(pontos_influentes, cook_distance[pontos_influentes], col = "red", pch = 19)



```

ESCOLHA DO MODELO (AIC, AICc, BIC)

A função gama com ligação identidade é o melhor modelo pelos três critérios utilizados. 
```{r, echo=FALSE, message=FALSE, warning=FALSE, fig.width=4, fig.height=3, fig.align='center'}

cat('AIC: ', '\n')
cat(paste0('Normal: ', round(AIC(fit_normal),2)), '\n') # normal
cat(paste0('Gama Link Indentity: ', round(AIC(fit.gama),2), '\n')) # gama link log
cat(paste0('Inversa Gaussiana link Identity: ', round(AIC(fit.IG),2)), '\n') # gama 

cat('AICc: ','\n\n')
cat(paste0('Normal: ', round(AICc(fit_normal),2)), '\n') # normal
cat(paste0('Gama Link Indentity: ', round(AICc(fit.gama),2), '\n')) # gama link log
cat(paste0('Inversa Gaussiana link Identity: ', round(AICc(fit.IG),2)), '\n') # gama link identidade


cat('BIC: ','\n\n')
cat(paste0('Normal: ', round(BIC(fit_normal),2)), '\n') # normal
cat(paste0('Gama Link Indentity: ', round(BIC(fit.gama),2), '\n')) # gama link log
cat(paste0('Inversa Gaussiana link Identity: ', round(BIC(fit.IG),2)), '\n') # gama link identidade

```
